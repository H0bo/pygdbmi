{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pygdbmi - Get Structured Output from GDB's Machine Interface Documentation https://cs01.github.io/pygdbmi Source Code https://github.com/cs01/pygdbmi Python ( py ) gdb machine interface ( mi ) GDB/MI is a line based machine oriented text interface to GDB and is activated by specifying using the --interpreter command line option (see Mode Options). It is specifically intended to support the development of systems which use the debugger as just one small component of a larger system. What's in the box? \u00b6 A function to parse gdb machine interface string output and return structured data types (Python dicts) that are JSON serializable. Useful for writing the backend to a gdb frontend. For example, gdbgui uses pygdbmi on the backend. A Python class to control and interact with gdb as a subprocess To get machine interface output from gdb, run gdb with the --interpreter=mi2 flag like so: gdb --interpreter=mi2 Installation \u00b6 pip install pygdbmi Compatibility \u00b6 Operating Systems \u00b6 Cross platform support for Linux, macOS and Windows Linux/Unix Ubuntu 14.04 and 16.04 have been tested to work. Other versions likely work as well. macOS Note: the error please check gdb is codesigned - see taskgated(8) can be fixed by codesigning gdb with these instructions . If the error is not fixed, please create an issue in github . Windows Windows 10 has been tested to work with MinGW and cygwin. gdb versions \u00b6 gdb 7.6+ has been tested. Older versions may work as well. Examples \u00b6 gdb mi defines a syntax for its output that is suitable for machine readability and scripting: example output : -> -break-insert main <- ^done,bkpt={number=\"1\",type=\"breakpoint\",disp=\"keep\", enabled=\"y\",addr=\"0x08048564\",func=\"main\",file=\"myprog.c\", fullname=\"/home/myprog.c\",line=\"68\",thread-groups=[\"i1\"], times=\"0\"} <- (gdb) Use pygdbmi.gdbmiparser.parse_response to turn that string output into a JSON serializable dictionary from pygdbmi import gdbmiparser from pprint import pprint response = gdbmiparser . parse_response ( '^done,bkpt={number=\"1\",type=\"breakpoint\",disp=\"keep\", enabled=\"y\",addr=\"0x08048564\",func=\"main\",file=\"myprog.c\",fullname=\"/home/myprog.c\",line=\"68\",thread-groups=[\"i1\"],times=\"0\"' ) pprint ( response ) > { 'message' : 'done' , 'payload' : { 'bkpt' : { 'addr' : '0x08048564' , 'disp' : 'keep' , 'enabled' : 'y' , 'file' : 'myprog.c' , 'fullname' : '/home/myprog.c' , 'func' : 'main' , 'line' : '68' , 'number' : '1' , 'thread-groups' : [ 'i1' ], 'times' : '0' , 'type' : 'breakpoint' }}, 'type' : 'result' } Programmatic Control Over gdb \u00b6 But how do you get the gdb output into Python in the first place? If you want, pygdbmi also has a class to control gdb as subprocess. You can write commands, and get structured output back: from pygdbmi.gdbcontroller import GdbController from pprint import pprint # Start gdb process gdbmi = GdbController () print ( gdbmi . get_subprocess_cmd ()) # print actual command run as subprocess # Load binary a.out and get structured response response = gdbmi . write ( '-file-exec-file a.out' ) pprint ( response ) [{ 'message' : u 'thread-group-added' , 'payload' : { u 'id' : u 'i1' }, 'type' : 'notify' }, { 'message' : u 'done' , 'payload' : None , 'type' : 'result' }] Now do whatever you want with gdb. All gdb commands, as well as gdb machine interface commands are acceptable. gdb mi commands give better structured output that is machine readable, rather than gdb console output. mi commands begin with a - . response = gdbmi . write ( '-break-insert main' ) # machine interface (MI) commands start with a '-' response = gdbmi . write ( 'break main' ) # normal gdb commands work too, but the return value is slightly different response = gdbmi . write ( '-exec-run' ) response = gdbmi . write ( 'run' ) response = gdbmi . write ( '-exec-next' , timeout_sec = 0.1 ) # the wait time can be modified from the default of 1 second response = gdbmi . write ( 'next' ) response = gdbmi . write ( 'next' , raise_error_on_timeout = False ) response = gdbmi . write ( 'next' , raise_error_on_timeout = True , timeout_sec = 0.01 ) response = gdbmi . write ( '-exec-continue' ) response = gdbmi . send_signal_to_gdb ( 'SIGKILL' ) # name of signal is okay response = gdbmi . send_signal_to_gdb ( 2 ) # value of signal is okay too response = gdbmi . interrupt_gdb () # sends SIGINT to gdb response = gdbmi . write ( 'continue' ) response = gdbmi . exit () Parsed Output Format \u00b6 Each parsed gdb response consists of a list of dictionaries. Each dictionary has keys message , payload , token , and type . message contains a textual message from gdb, which is not always present. When missing, this is None . payload contains the content of gdb's output, which can contain any of the following: dictionary , list , string . This too is not always present, and can be None depending on the response. token If an input command was prefixed with a (optional) token then the corresponding output for that command will also be prefixed by that same token. This field is only present for pygdbmi output types nofity and result . When missing, this is None . The type is defined based on gdb's various mi output record types , and can be result - the result of a gdb command, such as done , running , error , etc. notify - additional async changes that have occurred, such as breakpoint modified console - textual responses to cli commands log - debugging messages from gdb's internals output - output from target target - output from remote target done - when gdb has finished its output Contributing \u00b6 Documentation fixes, bug fixes, performance improvements, and functional improvements are welcome. You may want to create an issue before beginning work to make sure I am interested in merging it to the master branch. pygdbmi uses nox for automation. See available tasks with nox -l Run tests and lint with nox -s tests nox -s lint Projects Using pygdbmi \u00b6 gdbgui implements a browser-based frontend to gdb, using pygdbmi on the backend PINCE is a gdb frontend that aims to provide a reverse engineering tool and a reusable library focused on games. It uses pygdbmi to parse gdb/mi based output for some functions avatar\u00b2 is an orchestration framework for reversing and analysing firmware of embedded devices. It utilizes pygdbmi for internal communication to different analysis targets. Know of another project? Create a PR and add it here. Authors \u00b6 pygdbmi was written by Chad Smith with contributions from the community . Thanks especially to @mariusmue, @bobthekingofegypt, @mouuff, and @felipesere.","title":"Home"},{"location":"#whats-in-the-box","text":"A function to parse gdb machine interface string output and return structured data types (Python dicts) that are JSON serializable. Useful for writing the backend to a gdb frontend. For example, gdbgui uses pygdbmi on the backend. A Python class to control and interact with gdb as a subprocess To get machine interface output from gdb, run gdb with the --interpreter=mi2 flag like so: gdb --interpreter=mi2","title":"What's in the box?"},{"location":"#installation","text":"pip install pygdbmi","title":"Installation"},{"location":"#compatibility","text":"","title":"Compatibility"},{"location":"#operating-systems","text":"Cross platform support for Linux, macOS and Windows Linux/Unix Ubuntu 14.04 and 16.04 have been tested to work. Other versions likely work as well. macOS Note: the error please check gdb is codesigned - see taskgated(8) can be fixed by codesigning gdb with these instructions . If the error is not fixed, please create an issue in github . Windows Windows 10 has been tested to work with MinGW and cygwin.","title":"Operating Systems"},{"location":"#gdb-versions","text":"gdb 7.6+ has been tested. Older versions may work as well.","title":"gdb versions"},{"location":"#examples","text":"gdb mi defines a syntax for its output that is suitable for machine readability and scripting: example output : -> -break-insert main <- ^done,bkpt={number=\"1\",type=\"breakpoint\",disp=\"keep\", enabled=\"y\",addr=\"0x08048564\",func=\"main\",file=\"myprog.c\", fullname=\"/home/myprog.c\",line=\"68\",thread-groups=[\"i1\"], times=\"0\"} <- (gdb) Use pygdbmi.gdbmiparser.parse_response to turn that string output into a JSON serializable dictionary from pygdbmi import gdbmiparser from pprint import pprint response = gdbmiparser . parse_response ( '^done,bkpt={number=\"1\",type=\"breakpoint\",disp=\"keep\", enabled=\"y\",addr=\"0x08048564\",func=\"main\",file=\"myprog.c\",fullname=\"/home/myprog.c\",line=\"68\",thread-groups=[\"i1\"],times=\"0\"' ) pprint ( response ) > { 'message' : 'done' , 'payload' : { 'bkpt' : { 'addr' : '0x08048564' , 'disp' : 'keep' , 'enabled' : 'y' , 'file' : 'myprog.c' , 'fullname' : '/home/myprog.c' , 'func' : 'main' , 'line' : '68' , 'number' : '1' , 'thread-groups' : [ 'i1' ], 'times' : '0' , 'type' : 'breakpoint' }}, 'type' : 'result' }","title":"Examples"},{"location":"#programmatic-control-over-gdb","text":"But how do you get the gdb output into Python in the first place? If you want, pygdbmi also has a class to control gdb as subprocess. You can write commands, and get structured output back: from pygdbmi.gdbcontroller import GdbController from pprint import pprint # Start gdb process gdbmi = GdbController () print ( gdbmi . get_subprocess_cmd ()) # print actual command run as subprocess # Load binary a.out and get structured response response = gdbmi . write ( '-file-exec-file a.out' ) pprint ( response ) [{ 'message' : u 'thread-group-added' , 'payload' : { u 'id' : u 'i1' }, 'type' : 'notify' }, { 'message' : u 'done' , 'payload' : None , 'type' : 'result' }] Now do whatever you want with gdb. All gdb commands, as well as gdb machine interface commands are acceptable. gdb mi commands give better structured output that is machine readable, rather than gdb console output. mi commands begin with a - . response = gdbmi . write ( '-break-insert main' ) # machine interface (MI) commands start with a '-' response = gdbmi . write ( 'break main' ) # normal gdb commands work too, but the return value is slightly different response = gdbmi . write ( '-exec-run' ) response = gdbmi . write ( 'run' ) response = gdbmi . write ( '-exec-next' , timeout_sec = 0.1 ) # the wait time can be modified from the default of 1 second response = gdbmi . write ( 'next' ) response = gdbmi . write ( 'next' , raise_error_on_timeout = False ) response = gdbmi . write ( 'next' , raise_error_on_timeout = True , timeout_sec = 0.01 ) response = gdbmi . write ( '-exec-continue' ) response = gdbmi . send_signal_to_gdb ( 'SIGKILL' ) # name of signal is okay response = gdbmi . send_signal_to_gdb ( 2 ) # value of signal is okay too response = gdbmi . interrupt_gdb () # sends SIGINT to gdb response = gdbmi . write ( 'continue' ) response = gdbmi . exit ()","title":"Programmatic Control Over gdb"},{"location":"#parsed-output-format","text":"Each parsed gdb response consists of a list of dictionaries. Each dictionary has keys message , payload , token , and type . message contains a textual message from gdb, which is not always present. When missing, this is None . payload contains the content of gdb's output, which can contain any of the following: dictionary , list , string . This too is not always present, and can be None depending on the response. token If an input command was prefixed with a (optional) token then the corresponding output for that command will also be prefixed by that same token. This field is only present for pygdbmi output types nofity and result . When missing, this is None . The type is defined based on gdb's various mi output record types , and can be result - the result of a gdb command, such as done , running , error , etc. notify - additional async changes that have occurred, such as breakpoint modified console - textual responses to cli commands log - debugging messages from gdb's internals output - output from target target - output from remote target done - when gdb has finished its output","title":"Parsed Output Format"},{"location":"#contributing","text":"Documentation fixes, bug fixes, performance improvements, and functional improvements are welcome. You may want to create an issue before beginning work to make sure I am interested in merging it to the master branch. pygdbmi uses nox for automation. See available tasks with nox -l Run tests and lint with nox -s tests nox -s lint","title":"Contributing"},{"location":"#projects-using-pygdbmi","text":"gdbgui implements a browser-based frontend to gdb, using pygdbmi on the backend PINCE is a gdb frontend that aims to provide a reverse engineering tool and a reusable library focused on games. It uses pygdbmi to parse gdb/mi based output for some functions avatar\u00b2 is an orchestration framework for reversing and analysing firmware of embedded devices. It utilizes pygdbmi for internal communication to different analysis targets. Know of another project? Create a PR and add it here.","title":"Projects Using pygdbmi"},{"location":"#authors","text":"pygdbmi was written by Chad Smith with contributions from the community . Thanks especially to @mariusmue, @bobthekingofegypt, @mouuff, and @felipesere.","title":"Authors"},{"location":"CHANGELOG/","text":"pygdbmi release history \u00b6 0.9.0.3 \u00b6 Drop support for 2.7, 3.4 Add support for 3.7, 3.8 Add py.typed file so mypy can enforce type hints on pygdbmi Do not log in StringStream (#36) Updates to build and CI tests (use nox) Use mkdocs and mkdocstrings Doc updates 0.9.0.2 \u00b6 More doc updates 0.9.0.1 \u00b6 Update docs 0.9.0.0 \u00b6 Stop buffering output Use logger in GdbController; modify verbose arguments. Remove support for Python 3.3 0.8.4.0 \u00b6 Add method get_subprocess_cmd to view the gdb command run in the shell 0.8.3.0 \u00b6 Improve reading gdb responses on unix (performance, bugfix) (@mouuff) 0.8.2.0 \u00b6 Add support for record and replay (rr) gdb supplement 0.8.1.1 \u00b6 Discard unexpected text from gdb 0.8.1.0 \u00b6 Add native Windows support 0.8.0.0 \u00b6 Make parsing more efficient when gdb outputs large strings Add new methods to GdbController class: spawn_new_gdb_subprocess , send_signal_to_gdb , and interrupt_gdb 0.7.4.5 \u00b6 Update setup.py 0.7.4.4 \u00b6 Fix windows ctypes import (#23, @rudolfwalter) 0.7.4.3 \u00b6 Workaround gdb bug with repeated dictionary keys 0.7.4.2 \u00b6 Improved buffering of incomplete gdb mi output (@trapito) Remove support of Python 3.2 0.7.4.1 \u00b6 Preserve leading and trailing spaces in gdb/mi output (plus unit tests) Add unit test for buffering of gdb/mi output Documentation updates Refactoring 0.7.4.0 \u00b6 Add more exception types ( NoGdbProcessError , GdbTimeoutError ) Add logic fixes for Windows (@johncf) Use codecs.open() to open the readme.rst, to prevent locale related bugs (@mariusmue) 0.7.3.3 \u00b6 Add alternate pipe implementation for Windows 0.7.3.2 \u00b6 Replace epoll with select for osx compatibility (@felipesere) 0.7.3.1 \u00b6 Fix README 0.7.3.0 \u00b6 Add support for gdb/mi (optional) tokens (@mariusmue)","title":"Changelog"},{"location":"CHANGELOG/#pygdbmi-release-history","text":"","title":"pygdbmi release history"},{"location":"CHANGELOG/#0903","text":"Drop support for 2.7, 3.4 Add support for 3.7, 3.8 Add py.typed file so mypy can enforce type hints on pygdbmi Do not log in StringStream (#36) Updates to build and CI tests (use nox) Use mkdocs and mkdocstrings Doc updates","title":"0.9.0.3"},{"location":"CHANGELOG/#0902","text":"More doc updates","title":"0.9.0.2"},{"location":"CHANGELOG/#0901","text":"Update docs","title":"0.9.0.1"},{"location":"CHANGELOG/#0900","text":"Stop buffering output Use logger in GdbController; modify verbose arguments. Remove support for Python 3.3","title":"0.9.0.0"},{"location":"CHANGELOG/#0840","text":"Add method get_subprocess_cmd to view the gdb command run in the shell","title":"0.8.4.0"},{"location":"CHANGELOG/#0830","text":"Improve reading gdb responses on unix (performance, bugfix) (@mouuff)","title":"0.8.3.0"},{"location":"CHANGELOG/#0820","text":"Add support for record and replay (rr) gdb supplement","title":"0.8.2.0"},{"location":"CHANGELOG/#0811","text":"Discard unexpected text from gdb","title":"0.8.1.1"},{"location":"CHANGELOG/#0810","text":"Add native Windows support","title":"0.8.1.0"},{"location":"CHANGELOG/#0800","text":"Make parsing more efficient when gdb outputs large strings Add new methods to GdbController class: spawn_new_gdb_subprocess , send_signal_to_gdb , and interrupt_gdb","title":"0.8.0.0"},{"location":"CHANGELOG/#0745","text":"Update setup.py","title":"0.7.4.5"},{"location":"CHANGELOG/#0744","text":"Fix windows ctypes import (#23, @rudolfwalter)","title":"0.7.4.4"},{"location":"CHANGELOG/#0743","text":"Workaround gdb bug with repeated dictionary keys","title":"0.7.4.3"},{"location":"CHANGELOG/#0742","text":"Improved buffering of incomplete gdb mi output (@trapito) Remove support of Python 3.2","title":"0.7.4.2"},{"location":"CHANGELOG/#0741","text":"Preserve leading and trailing spaces in gdb/mi output (plus unit tests) Add unit test for buffering of gdb/mi output Documentation updates Refactoring","title":"0.7.4.1"},{"location":"CHANGELOG/#0740","text":"Add more exception types ( NoGdbProcessError , GdbTimeoutError ) Add logic fixes for Windows (@johncf) Use codecs.open() to open the readme.rst, to prevent locale related bugs (@mariusmue)","title":"0.7.4.0"},{"location":"CHANGELOG/#0733","text":"Add alternate pipe implementation for Windows","title":"0.7.3.3"},{"location":"CHANGELOG/#0732","text":"Replace epoll with select for osx compatibility (@felipesere)","title":"0.7.3.2"},{"location":"CHANGELOG/#0731","text":"Fix README","title":"0.7.3.1"},{"location":"CHANGELOG/#0730","text":"Add support for gdb/mi (optional) tokens (@mariusmue)","title":"0.7.3.0"},{"location":"api/gdbcontroller/","text":"This module defines the GdbController class which runs gdb as a subprocess and can write to it and read from it to get structured output. GdbController \u00b6 __init__ ( self , gdb_path = 'gdb' , gdb_args = None , time_to_check_for_additional_output_sec = 0.2 , rr = False , verbose = False ) \u00b6 Show source code in pygdbmi/gdbcontroller.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __init__ ( self , gdb_path : str = \"gdb\" , gdb_args : Optional [ List ] = None , time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , rr : bool = False , verbose : bool = False , ): \"\"\" Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Args: gdb_path: Command to run in shell to spawn new gdb subprocess gdb_args: Arguments to pass to shell when spawning new gdb subprocess time_to_check_for_additional_output_sec: When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. rr: Use the `rr replay` command instead of `gdb`. See rr-project.org for more info. verbose: Print verbose output if True Returns: New GdbController object \"\"\" if gdb_args is None : default_gdb_args = [ \"--nx\" , \"--quiet\" , \"--interpreter=mi2\" ] gdb_args = default_gdb_args self . verbose = verbose self . abs_gdb_path = None # abs path to gdb executable self . cmd = [] # type: List[str] self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . gdb_process = None self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) if rr : self . cmd = [ \"rr\" , \"replay\" ] + gdb_args else : if not gdb_path : raise ValueError ( \"a valid path to gdb must be specified\" ) else : abs_gdb_path = find_executable ( gdb_path ) if abs_gdb_path is None : raise ValueError ( 'gdb executable could not be resolved from \" %s \"' % gdb_path ) else : self . abs_gdb_path = abs_gdb_path self . cmd = [ self . abs_gdb_path ] + gdb_args self . _attach_logger ( verbose ) self . spawn_new_gdb_subprocess () Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Parameters Name Type Description Default gdb_path str Command to run in shell to spawn new gdb subprocess 'gdb' gdb_args List Arguments to pass to shell when spawning new gdb subprocess None time_to_check_for_additional_output_sec When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. 0.2 rr bool Use the rr replay command instead of gdb . See rr-project.org for more info. False verbose bool Print verbose output if True False Returns Type Description _empty New GdbController object exit ( self ) \u00b6 Show source code in pygdbmi/gdbcontroller.py 442 443 444 445 446 447 448 def exit ( self ) -> None : \"\"\"Terminate gdb process\"\"\" if self . gdb_process : self . gdb_process . terminate () self . gdb_process . communicate () self . gdb_process = None return None Terminate gdb process get_gdb_response ( self , timeout_sec = 1 , raise_error_on_timeout = True ) \u00b6 Show source code in pygdbmi/gdbcontroller.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True ): \"\"\"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Args: timeout_sec: Maximum time to wait for reponse. Must be >= 0. Will return after raise_error_on_timeout: Whether an exception should be raised if no response was found after timeout_sec Returns: List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Raises: GdbTimeoutError: if response is not received within timeout_sec ValueError: if select returned unexpected file number NoGdbProcessError: if there is no gdb subprocess running \"\"\" self . verify_valid_gdb_subprocess () if timeout_sec < 0 : self . logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 if USING_WINDOWS : retval = self . _get_responses_windows ( timeout_sec ) else : retval = self . _get_responses_unix ( timeout_sec ) if not retval and raise_error_on_timeout : raise GdbTimeoutError ( \"Did not get response from gdb after %s seconds\" % timeout_sec ) else : return retval Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Parameters Name Type Description Default timeout_sec float Maximum time to wait for reponse. Must be >= 0. Will return after 1 raise_error_on_timeout Whether an exception should be raised if no response was found after timeout_sec True Returns Type Description _empty List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Exceptions Type Description GdbTimeoutError if response is not received within timeout_sec ValueError if select returned unexpected file number NoGdbProcessError if there is no gdb subprocess running get_subprocess_cmd ( self ) \u00b6 Show source code in pygdbmi/gdbcontroller.py 126 127 128 129 130 def get_subprocess_cmd ( self ): \"\"\"Returns the shell-escaped string used to invoke the gdb subprocess. This is a string that can be executed directly in a shell. \"\"\" return \" \" . join ( quote ( c ) for c in self . cmd ) Returns the shell-escaped string used to invoke the gdb subprocess. This is a string that can be executed directly in a shell. interrupt_gdb ( self ) \u00b6 Show source code in pygdbmi/gdbcontroller.py 438 439 440 def interrupt_gdb ( self ): \"\"\"Send SIGINT (interrupt signal) to the gdb subprocess\"\"\" self . send_signal_to_gdb ( \"SIGINT\" ) Send SIGINT (interrupt signal) to the gdb subprocess send_signal_to_gdb ( self , signal_input ) \u00b6 Show source code in pygdbmi/gdbcontroller.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def send_signal_to_gdb ( self , signal_input ): \"\"\"Send signal name (case insensitive) or number to gdb subprocess These are all valid ways to call this method: ``` gdbmi.send_signal_to_gdb(2) gdbmi.send_signal_to_gdb('sigint') gdbmi.send_signal_to_gdb('SIGINT') ``` raises: ValueError: if signal_input is invalid NoGdbProcessError: if there is no gdb process to send a signal to \"\"\" try : signal = int ( signal_input ) except Exception : signal = SIGNAL_NAME_TO_NUM . get ( signal_input . upper ()) if not signal : raise ValueError ( 'Could not find signal corresponding to \" %s \"' % str ( signal ) ) if self . gdb_process : os . kill ( self . gdb_process . pid , signal ) else : raise NoGdbProcessError ( \"Cannot send signal to gdb process because no process exists.\" ) Send signal name (case insensitive) or number to gdb subprocess These are all valid ways to call this method: gdbmi.send_signal_to_gdb(2) gdbmi.send_signal_to_gdb('sigint') gdbmi.send_signal_to_gdb('SIGINT') Exceptions Type Description ValueError if signal_input is invalid NoGdbProcessError if there is no gdb process to send a signal to spawn_new_gdb_subprocess ( self ) \u00b6 Show source code in pygdbmi/gdbcontroller.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def spawn_new_gdb_subprocess ( self ): \"\"\"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id \"\"\" if self . gdb_process : self . logger . debug ( \"Killing current gdb subprocess (pid %d )\" % self . gdb_process . pid ) self . exit () self . logger . debug ( 'Launching gdb: \" %s \"' % \" \" . join ( self . cmd )) # Use pipes to the standard streams self . gdb_process = subprocess . Popen ( self . cmd , shell = False , stdout = subprocess . PIPE , stdin = subprocess . PIPE , stderr = subprocess . PIPE , bufsize = 0 , ) _make_non_blocking ( self . gdb_process . stdout ) _make_non_blocking ( self . gdb_process . stderr ) # save file numbers for use later self . stdout_fileno = self . gdb_process . stdout . fileno () self . stderr_fileno = self . gdb_process . stderr . fileno () self . stdin_fileno = self . gdb_process . stdin . fileno () self . read_list = [ self . stdout_fileno , self . stderr_fileno ] self . write_list = [ self . stdin_fileno ] # string buffers for unifinished gdb output self . _incomplete_output = { \"stdout\" : None , \"stderr\" : None } return self . gdb_process . pid Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id verify_valid_gdb_subprocess ( self ) \u00b6 Show source code in pygdbmi/gdbcontroller.py 171 172 173 174 175 176 177 178 179 180 181 def verify_valid_gdb_subprocess ( self ): \"\"\"Verify there is a process object, and that it is still running. Raise NoGdbProcessError if either of the above are not true.\"\"\" if not self . gdb_process : raise NoGdbProcessError ( \"gdb process is not attached\" ) elif self . gdb_process . poll () is not None : raise NoGdbProcessError ( \"gdb process has already finished with return code: %s \" % str ( self . gdb_process . poll ()) ) Verify there is a process object, and that it is still running. Raise NoGdbProcessError if either of the above are not true. write ( self , mi_cmd_to_write , timeout_sec = 1 , raise_error_on_timeout = True , read_response = True ) \u00b6 Show source code in pygdbmi/gdbcontroller.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , read_response : bool = True , ): \"\"\"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Args: mi_cmd_to_write: String to write to gdb. If list, it is joined by newlines. timeout_sec: Maximum number of seconds to wait for response before exiting. Must be >= 0. raise_error_on_timeout: If read_response is True, raise error if no response is received read_response: Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. Returns: List of parsed gdb responses if read_response is True, otherwise [] Raises: NoGdbProcessError: if there is no gdb subprocess running TypeError: if mi_cmd_to_write is not valid \"\"\" self . verify_valid_gdb_subprocess () if timeout_sec < 0 : self . logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 # Ensure proper type of the mi command if isinstance ( mi_cmd_to_write , str ): mi_cmd_to_write_str = mi_cmd_to_write elif isinstance ( mi_cmd_to_write , list ): mi_cmd_to_write_str = \" \\n \" . join ( mi_cmd_to_write ) else : raise TypeError ( \"The gdb mi command must a be str or list. Got \" + str ( type ( mi_cmd_to_write )) ) self . logger . debug ( \"writing: %s \" , mi_cmd_to_write ) if not mi_cmd_to_write_str . endswith ( \" \\n \" ): mi_cmd_to_write_nl = mi_cmd_to_write_str + \" \\n \" else : mi_cmd_to_write_nl = mi_cmd_to_write_str if USING_WINDOWS : # select not implemented in windows for pipes # assume it's always ready outputready = [ self . stdin_fileno ] else : _ , outputready , _ = select . select ([], self . write_list , [], timeout_sec ) for fileno in outputready : if fileno == self . stdin_fileno : # ready to write self . gdb_process . stdin . write ( # type: ignore mi_cmd_to_write_nl . encode () ) # don't forget to flush for Python3, otherwise gdb won't realize there is data # to evaluate, and we won't get a response self . gdb_process . stdin . flush () # type: ignore else : self . logger . error ( \"got unexpected fileno %d \" % fileno ) if read_response is True : return self . get_gdb_response ( timeout_sec = timeout_sec , raise_error_on_timeout = raise_error_on_timeout ) else : return [] Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Parameters Name Type Description Default mi_cmd_to_write Union[str, List[str]] String to write to gdb. If list, it is joined by newlines. required timeout_sec Maximum number of seconds to wait for response before exiting. Must be >= 0. 1 raise_error_on_timeout bool If read_response is True, raise error if no response is received True read_response bool Block and read response. If there is a separate thread running, True Returns Type Description _empty List of parsed gdb responses if read_response is True, otherwise [] Exceptions Type Description NoGdbProcessError if there is no gdb subprocess running TypeError if mi_cmd_to_write is not valid GdbTimeoutError \u00b6 Raised when no response is recieved from gdb after the timeout has been triggered NoGdbProcessError \u00b6 Raise when trying to interact with gdb subprocess, but it does not exist. It may have been killed and removed, or failed to initialize for some reason.","title":"gdbcontroller"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController","text":"","title":"GdbController"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.__init__","text":"Show source code in pygdbmi/gdbcontroller.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __init__ ( self , gdb_path : str = \"gdb\" , gdb_args : Optional [ List ] = None , time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , rr : bool = False , verbose : bool = False , ): \"\"\" Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Args: gdb_path: Command to run in shell to spawn new gdb subprocess gdb_args: Arguments to pass to shell when spawning new gdb subprocess time_to_check_for_additional_output_sec: When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. rr: Use the `rr replay` command instead of `gdb`. See rr-project.org for more info. verbose: Print verbose output if True Returns: New GdbController object \"\"\" if gdb_args is None : default_gdb_args = [ \"--nx\" , \"--quiet\" , \"--interpreter=mi2\" ] gdb_args = default_gdb_args self . verbose = verbose self . abs_gdb_path = None # abs path to gdb executable self . cmd = [] # type: List[str] self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . gdb_process = None self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) if rr : self . cmd = [ \"rr\" , \"replay\" ] + gdb_args else : if not gdb_path : raise ValueError ( \"a valid path to gdb must be specified\" ) else : abs_gdb_path = find_executable ( gdb_path ) if abs_gdb_path is None : raise ValueError ( 'gdb executable could not be resolved from \" %s \"' % gdb_path ) else : self . abs_gdb_path = abs_gdb_path self . cmd = [ self . abs_gdb_path ] + gdb_args self . _attach_logger ( verbose ) self . spawn_new_gdb_subprocess () Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Parameters Name Type Description Default gdb_path str Command to run in shell to spawn new gdb subprocess 'gdb' gdb_args List Arguments to pass to shell when spawning new gdb subprocess None time_to_check_for_additional_output_sec When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. 0.2 rr bool Use the rr replay command instead of gdb . See rr-project.org for more info. False verbose bool Print verbose output if True False Returns Type Description _empty New GdbController object","title":"__init__()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.exit","text":"Show source code in pygdbmi/gdbcontroller.py 442 443 444 445 446 447 448 def exit ( self ) -> None : \"\"\"Terminate gdb process\"\"\" if self . gdb_process : self . gdb_process . terminate () self . gdb_process . communicate () self . gdb_process = None return None Terminate gdb process","title":"exit()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.get_gdb_response","text":"Show source code in pygdbmi/gdbcontroller.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True ): \"\"\"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Args: timeout_sec: Maximum time to wait for reponse. Must be >= 0. Will return after raise_error_on_timeout: Whether an exception should be raised if no response was found after timeout_sec Returns: List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Raises: GdbTimeoutError: if response is not received within timeout_sec ValueError: if select returned unexpected file number NoGdbProcessError: if there is no gdb subprocess running \"\"\" self . verify_valid_gdb_subprocess () if timeout_sec < 0 : self . logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 if USING_WINDOWS : retval = self . _get_responses_windows ( timeout_sec ) else : retval = self . _get_responses_unix ( timeout_sec ) if not retval and raise_error_on_timeout : raise GdbTimeoutError ( \"Did not get response from gdb after %s seconds\" % timeout_sec ) else : return retval Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Parameters Name Type Description Default timeout_sec float Maximum time to wait for reponse. Must be >= 0. Will return after 1 raise_error_on_timeout Whether an exception should be raised if no response was found after timeout_sec True Returns Type Description _empty List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Exceptions Type Description GdbTimeoutError if response is not received within timeout_sec ValueError if select returned unexpected file number NoGdbProcessError if there is no gdb subprocess running","title":"get_gdb_response()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.get_subprocess_cmd","text":"Show source code in pygdbmi/gdbcontroller.py 126 127 128 129 130 def get_subprocess_cmd ( self ): \"\"\"Returns the shell-escaped string used to invoke the gdb subprocess. This is a string that can be executed directly in a shell. \"\"\" return \" \" . join ( quote ( c ) for c in self . cmd ) Returns the shell-escaped string used to invoke the gdb subprocess. This is a string that can be executed directly in a shell.","title":"get_subprocess_cmd()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.interrupt_gdb","text":"Show source code in pygdbmi/gdbcontroller.py 438 439 440 def interrupt_gdb ( self ): \"\"\"Send SIGINT (interrupt signal) to the gdb subprocess\"\"\" self . send_signal_to_gdb ( \"SIGINT\" ) Send SIGINT (interrupt signal) to the gdb subprocess","title":"interrupt_gdb()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.send_signal_to_gdb","text":"Show source code in pygdbmi/gdbcontroller.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def send_signal_to_gdb ( self , signal_input ): \"\"\"Send signal name (case insensitive) or number to gdb subprocess These are all valid ways to call this method: ``` gdbmi.send_signal_to_gdb(2) gdbmi.send_signal_to_gdb('sigint') gdbmi.send_signal_to_gdb('SIGINT') ``` raises: ValueError: if signal_input is invalid NoGdbProcessError: if there is no gdb process to send a signal to \"\"\" try : signal = int ( signal_input ) except Exception : signal = SIGNAL_NAME_TO_NUM . get ( signal_input . upper ()) if not signal : raise ValueError ( 'Could not find signal corresponding to \" %s \"' % str ( signal ) ) if self . gdb_process : os . kill ( self . gdb_process . pid , signal ) else : raise NoGdbProcessError ( \"Cannot send signal to gdb process because no process exists.\" ) Send signal name (case insensitive) or number to gdb subprocess These are all valid ways to call this method: gdbmi.send_signal_to_gdb(2) gdbmi.send_signal_to_gdb('sigint') gdbmi.send_signal_to_gdb('SIGINT') Exceptions Type Description ValueError if signal_input is invalid NoGdbProcessError if there is no gdb process to send a signal to","title":"send_signal_to_gdb()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.spawn_new_gdb_subprocess","text":"Show source code in pygdbmi/gdbcontroller.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def spawn_new_gdb_subprocess ( self ): \"\"\"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id \"\"\" if self . gdb_process : self . logger . debug ( \"Killing current gdb subprocess (pid %d )\" % self . gdb_process . pid ) self . exit () self . logger . debug ( 'Launching gdb: \" %s \"' % \" \" . join ( self . cmd )) # Use pipes to the standard streams self . gdb_process = subprocess . Popen ( self . cmd , shell = False , stdout = subprocess . PIPE , stdin = subprocess . PIPE , stderr = subprocess . PIPE , bufsize = 0 , ) _make_non_blocking ( self . gdb_process . stdout ) _make_non_blocking ( self . gdb_process . stderr ) # save file numbers for use later self . stdout_fileno = self . gdb_process . stdout . fileno () self . stderr_fileno = self . gdb_process . stderr . fileno () self . stdin_fileno = self . gdb_process . stdin . fileno () self . read_list = [ self . stdout_fileno , self . stderr_fileno ] self . write_list = [ self . stdin_fileno ] # string buffers for unifinished gdb output self . _incomplete_output = { \"stdout\" : None , \"stderr\" : None } return self . gdb_process . pid Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id","title":"spawn_new_gdb_subprocess()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.verify_valid_gdb_subprocess","text":"Show source code in pygdbmi/gdbcontroller.py 171 172 173 174 175 176 177 178 179 180 181 def verify_valid_gdb_subprocess ( self ): \"\"\"Verify there is a process object, and that it is still running. Raise NoGdbProcessError if either of the above are not true.\"\"\" if not self . gdb_process : raise NoGdbProcessError ( \"gdb process is not attached\" ) elif self . gdb_process . poll () is not None : raise NoGdbProcessError ( \"gdb process has already finished with return code: %s \" % str ( self . gdb_process . poll ()) ) Verify there is a process object, and that it is still running. Raise NoGdbProcessError if either of the above are not true.","title":"verify_valid_gdb_subprocess()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.write","text":"Show source code in pygdbmi/gdbcontroller.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , read_response : bool = True , ): \"\"\"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Args: mi_cmd_to_write: String to write to gdb. If list, it is joined by newlines. timeout_sec: Maximum number of seconds to wait for response before exiting. Must be >= 0. raise_error_on_timeout: If read_response is True, raise error if no response is received read_response: Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. Returns: List of parsed gdb responses if read_response is True, otherwise [] Raises: NoGdbProcessError: if there is no gdb subprocess running TypeError: if mi_cmd_to_write is not valid \"\"\" self . verify_valid_gdb_subprocess () if timeout_sec < 0 : self . logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 # Ensure proper type of the mi command if isinstance ( mi_cmd_to_write , str ): mi_cmd_to_write_str = mi_cmd_to_write elif isinstance ( mi_cmd_to_write , list ): mi_cmd_to_write_str = \" \\n \" . join ( mi_cmd_to_write ) else : raise TypeError ( \"The gdb mi command must a be str or list. Got \" + str ( type ( mi_cmd_to_write )) ) self . logger . debug ( \"writing: %s \" , mi_cmd_to_write ) if not mi_cmd_to_write_str . endswith ( \" \\n \" ): mi_cmd_to_write_nl = mi_cmd_to_write_str + \" \\n \" else : mi_cmd_to_write_nl = mi_cmd_to_write_str if USING_WINDOWS : # select not implemented in windows for pipes # assume it's always ready outputready = [ self . stdin_fileno ] else : _ , outputready , _ = select . select ([], self . write_list , [], timeout_sec ) for fileno in outputready : if fileno == self . stdin_fileno : # ready to write self . gdb_process . stdin . write ( # type: ignore mi_cmd_to_write_nl . encode () ) # don't forget to flush for Python3, otherwise gdb won't realize there is data # to evaluate, and we won't get a response self . gdb_process . stdin . flush () # type: ignore else : self . logger . error ( \"got unexpected fileno %d \" % fileno ) if read_response is True : return self . get_gdb_response ( timeout_sec = timeout_sec , raise_error_on_timeout = raise_error_on_timeout ) else : return [] Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Parameters Name Type Description Default mi_cmd_to_write Union[str, List[str]] String to write to gdb. If list, it is joined by newlines. required timeout_sec Maximum number of seconds to wait for response before exiting. Must be >= 0. 1 raise_error_on_timeout bool If read_response is True, raise error if no response is received True read_response bool Block and read response. If there is a separate thread running, True Returns Type Description _empty List of parsed gdb responses if read_response is True, otherwise [] Exceptions Type Description NoGdbProcessError if there is no gdb subprocess running TypeError if mi_cmd_to_write is not valid","title":"write()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbTimeoutError","text":"Raised when no response is recieved from gdb after the timeout has been triggered","title":"GdbTimeoutError"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.NoGdbProcessError","text":"Raise when trying to interact with gdb subprocess, but it does not exist. It may have been killed and removed, or failed to initialize for some reason.","title":"NoGdbProcessError"},{"location":"api/gdbmiparser/","text":"Python parser for gdb's machine interface interpreter. Parses string output from gdb with the --interpreter=mi2 flag into structured objects. See more at https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI.html#GDB_002fMI parse_response ( gdb_mi_text ) \u00b6 Show source code in pygdbmi/gdbmiparser.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def parse_response ( gdb_mi_text : str ) -> Dict : \"\"\"Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Args: gdb_mi_text: String output from gdb Returns: dictionary with keys \"type\", \"message\", \"payload\", \"token\" \"\"\" stream = StringStream ( gdb_mi_text , debug = _DEBUG ) if _GDB_MI_NOTIFY_RE . match ( gdb_mi_text ): token , message , payload = _get_notify_msg_and_payload ( gdb_mi_text , stream ) return { \"type\" : \"notify\" , \"message\" : message , \"payload\" : payload , \"token\" : token , } elif _GDB_MI_RESULT_RE . match ( gdb_mi_text ): token , message , payload = _get_result_msg_and_payload ( gdb_mi_text , stream ) return { \"type\" : \"result\" , \"message\" : message , \"payload\" : payload , \"token\" : token , } elif _GDB_MI_CONSOLE_RE . match ( gdb_mi_text ): match = _GDB_MI_CONSOLE_RE . match ( gdb_mi_text ) if match : payload = match . groups ()[ 0 ] else : payload = None return { \"type\" : \"console\" , \"message\" : None , \"payload\" : payload , } elif _GDB_MI_LOG_RE . match ( gdb_mi_text ): match = _GDB_MI_LOG_RE . match ( gdb_mi_text ) if match : payload = match . groups ()[ 0 ] else : payload = None return { \"type\" : \"log\" , \"message\" : None , \"payload\" : payload } elif _GDB_MI_TARGET_OUTPUT_RE . match ( gdb_mi_text ): match = _GDB_MI_TARGET_OUTPUT_RE . match ( gdb_mi_text ) if match : payload = match . groups ()[ 0 ] else : payload = None return { \"type\" : \"target\" , \"message\" : None , \"payload\" : payload } elif response_is_finished ( gdb_mi_text ): return { \"type\" : \"done\" , \"message\" : None , \"payload\" : None } else : # This was not gdb mi output, so it must have just been printed by # the inferior program that's being debugged return { \"type\" : \"output\" , \"message\" : None , \"payload\" : gdb_mi_text } Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Parameters Name Type Description Default gdb_mi_text str String output from gdb required Returns Type Description Dict dictionary with keys \"type\", \"message\", \"payload\", \"token\" response_is_finished ( gdb_mi_text ) \u00b6 Show source code in pygdbmi/gdbmiparser.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def response_is_finished ( gdb_mi_text : str ) -> bool : \"\"\"Return true if the gdb mi response is ending Args: gdb_mi_text: String output from gdb Returns: True if gdb response is finished \"\"\" if _GDB_MI_RESPONSE_FINISHED_RE . match ( gdb_mi_text ): return True else : return False Return true if the gdb mi response is ending Parameters Name Type Description Default gdb_mi_text str String output from gdb required Returns Type Description bool True if gdb response is finished","title":"gdbmiparser"},{"location":"api/gdbmiparser/#pygdbmi.gdbmiparser.parse_response","text":"Show source code in pygdbmi/gdbmiparser.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def parse_response ( gdb_mi_text : str ) -> Dict : \"\"\"Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Args: gdb_mi_text: String output from gdb Returns: dictionary with keys \"type\", \"message\", \"payload\", \"token\" \"\"\" stream = StringStream ( gdb_mi_text , debug = _DEBUG ) if _GDB_MI_NOTIFY_RE . match ( gdb_mi_text ): token , message , payload = _get_notify_msg_and_payload ( gdb_mi_text , stream ) return { \"type\" : \"notify\" , \"message\" : message , \"payload\" : payload , \"token\" : token , } elif _GDB_MI_RESULT_RE . match ( gdb_mi_text ): token , message , payload = _get_result_msg_and_payload ( gdb_mi_text , stream ) return { \"type\" : \"result\" , \"message\" : message , \"payload\" : payload , \"token\" : token , } elif _GDB_MI_CONSOLE_RE . match ( gdb_mi_text ): match = _GDB_MI_CONSOLE_RE . match ( gdb_mi_text ) if match : payload = match . groups ()[ 0 ] else : payload = None return { \"type\" : \"console\" , \"message\" : None , \"payload\" : payload , } elif _GDB_MI_LOG_RE . match ( gdb_mi_text ): match = _GDB_MI_LOG_RE . match ( gdb_mi_text ) if match : payload = match . groups ()[ 0 ] else : payload = None return { \"type\" : \"log\" , \"message\" : None , \"payload\" : payload } elif _GDB_MI_TARGET_OUTPUT_RE . match ( gdb_mi_text ): match = _GDB_MI_TARGET_OUTPUT_RE . match ( gdb_mi_text ) if match : payload = match . groups ()[ 0 ] else : payload = None return { \"type\" : \"target\" , \"message\" : None , \"payload\" : payload } elif response_is_finished ( gdb_mi_text ): return { \"type\" : \"done\" , \"message\" : None , \"payload\" : None } else : # This was not gdb mi output, so it must have just been printed by # the inferior program that's being debugged return { \"type\" : \"output\" , \"message\" : None , \"payload\" : gdb_mi_text } Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Parameters Name Type Description Default gdb_mi_text str String output from gdb required Returns Type Description Dict dictionary with keys \"type\", \"message\", \"payload\", \"token\"","title":"parse_response()"},{"location":"api/gdbmiparser/#pygdbmi.gdbmiparser.response_is_finished","text":"Show source code in pygdbmi/gdbmiparser.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def response_is_finished ( gdb_mi_text : str ) -> bool : \"\"\"Return true if the gdb mi response is ending Args: gdb_mi_text: String output from gdb Returns: True if gdb response is finished \"\"\" if _GDB_MI_RESPONSE_FINISHED_RE . match ( gdb_mi_text ): return True else : return False Return true if the gdb mi response is ending Parameters Name Type Description Default gdb_mi_text str String output from gdb required Returns Type Description bool True if gdb response is finished","title":"response_is_finished()"}]}